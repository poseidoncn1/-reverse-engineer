### ARM 汇编

```

```

### RAM指令集

```
分支跳转指令
加载存储指令
数据处理指令
程序状态寄存器访问指令
移位指令

```

- 分支跳转指令（类似 goto）

  ```
  B{条件} <目的地址>  跳转指令
  BL{条件} <目的地址> 带返回的跳转指令  （相当于CALL）
  BX{条件} <目的地址><Rm> 带状态切换的跳转指令 （函数末尾，类似 ret） 跳转到LR指定的地址，并根据LR中数据的最低位来切换处理器状态，若目标地址最低位bit[0]位0，跳转时自动将CPSR中的标志位T复位，即把目标地址代码解释为ARM代码；若目标地址的bit[0]为1，则跳转时自动将CPSR中的标志位T置位，即解释位Thumb代码
  BLX{条件} <目的地址><Rm> 带返回和状态切换的跳转指令

  {条件} 判断程序状态寄存器中标志位
  带返回 即执行指令时会将下一条指令地址存入r14（LR)中
  带状态切换 根据<Rm>的值进行ARM到Thumb的自动转换   thumb 16  ARM 32
  ```

  - 条件
    ![1614920483779](.\images\1614920483779.png)


  - 小技巧

    ```
    IDA->Option->Genaral->auto comments
    ```

- 加载和存储指令

  ```
  主要用户寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。常用的加载存储指令如下


  LDR{条件} 目的寄存器，<存储器地址>   加载到寄存器
  LDR{条件}B 目的寄存器，<存储器地址>  加载8位，剩下位0
  LDR{条件}H 目的寄存器，<存储器地址>  加载16位剩下位0
  LDR{条件}W 目的寄存器，<存储器地址>  加载32位剩下位0

  STR{条件} 源寄存器，<存储器地址>    寄存器存入内存
  STR{条件}B 源寄存器,<存储器地址>    存放8位
  STR{条件}H 源寄存器,<存储器地址>    存放16位

  LDM{条件}{类型}基址寄存器{|},寄存器列表{^} 批量存入寄存器列表中的寄存器 
  STM{条件}{类型} 基址寄存器{|},寄存器列表{^} 批量存入基址寄存器，指向的地址 

  类似：mov

  例子： 规律：[]代表地址计算完毕，数据存放到R0。如果右边还有寄存器，那么计算地址后存入[]。
  LDR R0,[R1,R2]!  ->R1+R2指向数据存入R0。 加！是将新地址R1+R2写入R1中。
  LDR R0,[R1],R2 ->R1指向数据存入R0。新地址R1+R2写入R1

  LDR R0,[R1],R2,#8  ->R1指向数据存入R0。新地址R1+R2+8写入R1。
  LDR R0，[R1,,R2，LSL #2]!  ->R1+R2*4指向数据存入R0。新地址R1+R2*4写入R1。（LSL#左移）


  批量数据加载/存储指令-LDM(或STM)指令
  从由基址寄存器


  ```

  - 批量数据加载/存储指令-LDM(或STM)指令

    ```
    从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，{类型}为以下几种情况：

    FD满递减堆栈

    LDM(或STM){条件}{类型}基址寄存器{!},寄存器列表{^}
    {！}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。

    {^} 为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。

    LDMFD R13!,{R0,R4-R12,LR}

    LDMFD写在前面的寄存器先出栈
    STMFD写在后面的寄存器先入栈

    类似：push pop

    IDA 先D变为数据，再按 'C' 转指令,再选择第一行，按 'P',解释称为函数

    流水线：
    ADD R0,PC  经过取指令，译码，最后到执行，执行了两步，ARM指令 PC+8，thumb 指令 PC+4。ARM指令长度4个字节，thumb指令长度2个字节。

    IDA 右侧状态标志位 T为1，为thumb指令，Option->General->Number of Opcode bytes 4。

    IDA->options->auto comment

    ```

    ![1614931243492](.\images\1614931243492.png)

- 数据处理指令

  ```
  数据传送指令
  算术逻辑运算指令
  比较指令
  ```

  - 数据传送指令

    ```
    寄存器和存储器之间的 数据的双向传输
    MOV MVN
    MOV {条件}{S} 目的寄存器 操作数  数据传送指令
    MVN{条件}{S} 目的寄存器 操作数   数据取反传送指令
    //S 决定指令的操作更新CPSR条件标志位
    //MVN MOV不同之处在传送之前按位取反
    NDK ARM汇编，和C++代码混搭:
    __asm__("mov r1,r0,lsl#3 ");//r0左移3位 传给r1（LSL#左移）

    __asm__("mvn r0,#0");//r0=1


    ```

  - 算数逻辑指令

    ```
    算术逻辑运算指令完成常用的算术与逻辑运算，该类指令不但将运算结果保存在目的寄存器中，同时更新CPSR相应条件标志位
    ADD ADC SUB SBC RSB RSC AND ORR EOR BIC
    //它们操作数1应时一个寄存器，操作数2可以时一个寄存器，被移位的寄存器，或一个立即数。
    ADC{}{S}目的寄存器，操作数1，操作数2
    ADC 用于把两个操作数相加，在加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。它使用一个进位标志位，这样就可以做比32位大的数的加法运算。注意不要忘记设置S后缀来更改进位标志。操作数1应时一个寄存器，操作数2可以时一个寄存器，被移位的寄存器，或一个立即数。

    SUB R0,R2,R3,LSL#1//R0=R2-(R3<<1)

    SBC{条件}{S} 目的寄存器，操作数1，操作数2
    操作数1减去操作数2，在减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。操作数1应该是一个寄存器，操作数2可以是寄存器，被移位的寄存器 或立即数。该指令使用进位标志位来表示借位，这样就可以做大于32位的减法，注意不要顽疾设置S后缀来更改进位标志。该指令可用于由符号数或无符号数的减法运算。
    SBCS R0,R1,R2;R0 = R1-R2 -!C;

    RSB{}{S}目的寄存器，操作数1，操作数2
    逆向减法
    RSB R0,R1,R3，LSL#1  //  R0= R3*2-R1

    RSC{}{S}目的寄存器，操作数1，操作数2
    逆向带进位减法指令
    RSC R0,R1,R2;   R0=R2-R1-!C

    AND逻辑与运算指令
    AND {}{S}目的寄存器，操作数1，操作数2
    AND R0,R0,#3 //该指令保持R0的0、1位，其余清零

    ORR逻辑或运算指令

    EOR R0,R0,#3//异或

    BIC
    //清除操作数1的某些位，并把结果放置到目的寄存器中。如果操作数2，32位中设置一位为1，则清除这一位。未设置0，保持不变。

    BIC R0,R0,#%1011;  //该指令清除R0中的位0 1 3 其余的位保持不变
    ```

  - 比较指令

    ```
    不保存运算结果，只更新CPSR中相应的条件标志位。

    CMP  CMN TST TEQ
    CMP{条件}操作数1 ，操作数2   比较指令   操作数1-操作数2
    CMN{条件}操作数1 ，操作数2   比较反值指令  操作数1+操作数2
    TST{条件}操作数1，操作数2    位测试指令   按位与运算
    TEQ{条件}操作数1，操作数2    相等测试指令   按位异或   +按位加结果

    比较或者测试时，会影响CPSR寄存器中条件标志位，不保留结果

    CMP

    TST R1，#%1      //%1  二进制1
    TST R1,#0xff
    ```

    ​
